# 马尔科夫
这个J a v a程序比前面的C程序小了不少，并照顾到更多的细节， V e c t o r和H a s h t a b l e是
其中最明显的例子。一般地说，这里的存储管理比较简单，因为向量本身能够自动增长，废
料收集将管理回收那些不再引用的存储。但是，为了能使用 H a s h t a b l e类，我们还必须自己
写函数h a s h C o d e和e q u a l s。可见J a v a并没有照顾好一切细节。

面向对象的语言有它们的优越之处，对C + +或J a v a的实现做点小修改，就可能使它们的数据结构适合英语之外的其他文本，
例如程序(在那里空格可能是重要的东西 )，或者乐谱，甚至产生测试序列的鼠标点击和菜单选
择。

当然，即使数据结构本身差不多，在程序的一般表现方面，在源代码的大小方面，在程
序执行性能方面也可以存在很大差异。粗略地说，使用较高级的语言比更低级的语言写出的
程序速度更慢，但这种说法只是定性的，把它随意推广也是不明智的。大型构件，如 C + +的
S T L或脚本语言里的关联数组、字符串处理，能使代码更紧凑，开发时间也更短。当然这些
东西不是没有代价的，但是，性能方面的损失对于大部分程序而言可能并不那么重要。比如
马尔可夫这样的程序，它不过只运行几秒钟。

当系统内部提供的代码太多时，人们将无法知道程序在其表面之下到底做了什么。我们
应该如何评价这种对控制和洞察力的丧失，这是更不清楚的事情。这也就是 S T L版本中遇到
的情况，它的性能无法预料，也没有很容易的办法去解决问题。我们使用过一个很不成熟的
实现，必须对它做一些修正后才能够运行我们的程序。但是，很少有人能有资源和精力去弄
清其中的问题并且修复它们。

目前存在着一种对软件的广泛的不断增长的关注：当程序库、界面和工具变得越来越复
杂时，它们也变得更难以理解和控制了。当所有东西都正常运转时，功能丰富的程序设计环
境可以是非常有生产效率的，但是如果它们出了毛病，那就没什么东西可以依靠了。如果问
题牵涉到的是性能或者某些难于捉摸的逻辑错误时，我们很可能根本没有意识到有什么东西
出了毛病。

在这个程序的设计和实现过程中，我们看到了许多东西，这些对于更大的程序是很有教
益的。首先是选择简单算法和数据结构的重要性，应该选择那些能在合理时间内解决具有预
期规模的问题的最简单的东西。如果有人已经把它写好并放在库里，那是最好了。我们的
C++ 程序由此获益匪浅。
按照B r o o k s的建议，我们发现最好是从数据结构开始，在关于可以使用哪些算法的知识
的指导下进行详细设计。当数据结构安置好后，代码就比较容易组织了。

要想先把一个程序完全设计好，然后再构造它，这是非常困难的。构造现实的程序总需
要重复和试验。构造过程逼迫人们去把前面粗略做出的决定弄清楚。这正是我们在写这些程
序中遇到的情况。这个程序经历了许多细节方面的变化。应该尽可能从简单的东西开始，根
据获得的经验逐步发展。

隐藏在设计模式后面的基本思想是：大部分程序所采用的不过是很少几种不同的设计结
构，与此类似，实际上也只有不多的几种基本数据结构。说的远一点，这与我们在第 1章讨论
过的编码习惯用法也是很相像的。
《设计模式：可重用面向对象软件的要素》
